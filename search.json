[{"title":"vue项目里全局变量process.env的作用","url":"/2020/01/12/env/","content":"## process.env的用途\n\n    在使用vue-cli开发项目中，我相信大家都有过这样类似的需求，区分开发环境跟生产环境作出\n    相对应的配置，那么这个时候就要用到这个“process.env”的全局变量了(例如是否替换接口的\n    地址，代码是否压缩等）webpack就是通过process.env属性做区分以此来执行相应的操作。\n\n## 什么是process.env\n    process对象是一个 global （全局变量），提供有关信息，控制当前 Node.js 进程。作为\n    一个对象，它对于 Node.js 应用程序始终是可用的，故无需使用 require()。通过这个所谓\n    的进程，我们可以通过它拿到一些有意思的东西\n\n## 应用\n    在webpack的配置文件里，你会经常看到这样的代码：\n~~~bash\n    // webpack.config.js\n    module.exports = {\n        mode: process.env.NODE_ENV === 'production' ? 'production' : 'development'\n    }\n~~~\n    其实这里就是取到peocess.env_NODE_ENV的值，然后利用这个值来区分当前的环境模式。\n    在vue-cli3里，我们尝试做区分去执行不同的npm命令得到不同环境对应的操作，vue-cli3\n    里有三个环境配置文件：\n-   development : 开发环境\n-   prod： 正式环境\n-   test： 测试环境\n    ![](env/env_img.png?size=545x184)\n    举个例子：\n    这是dev环境对应的API地址\n    ![](env/env_development.png?size=545x184)\n    这是prod环境对应的API地址\n    ![](env/env_prod.png?size=545x184)\n    它的实现逻辑和原理与之前还是一样的，还是基于babel-plugin-dynamic-import-node来实现的。之所以在vue-cli中只需要设置一个变量就可以了，是借用了vue-cli它的默认配置，你可以通过传递 --mode 选项参数为命令行覆写默认的模式。例如，如果你想要在构建命令中使用开发环境变量，请在你的 package.json 脚本中加入：\n    ![](env/pack.png?size=700x213)\n    可以尝试在main.js里去打印 process.env.VUE_APP_API，然后修改package.json里--mode参数切换环境\n    prpcess.env.VUE_APP_API的值对应的就是之前你配置好的地址。由此我们可以利用这个全局变量去做很多事\n    比如在我们的请求封装时，我们可以直接使用process.env.VUE_APP_API作为接口前缀，跟随环境的不同对应\n    不同的地址。同时在webpack配置中我们也可以用这个变量加以判断，使其在不同环境使用不同的配置选项。\n\n### 总结\n    在Windows 开发部署的项目，可能在 Mac 系统无法正常打包，反之亦然。为了解决这个问题，有人就开发了 cross-env。\n\n    cross-env是一个跨平台设置环境变量的第三方包，它可以让你只配置一行命令，就能轻松地在多个平台设置环境变量。首先先安装\n~~~bash\n    npm install --save-dev cross-env \n~~~\n    然后去配置你的package.json\n~~~bash\n    // package.json\n    {\n        \"scripts\": {\n            \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --open --hot\",\n            \"build\": \"cross-env NODE_ENV=production webpack --mode=production  --progress --hide-modules\"\n        },\n    }\n~~~","categories":["vue"]},{"title":"ios端软件盘收起底部留白","url":"/2020/01/04/ios/","content":"\n\n\n### ios移动端里常见软件盘收起，底部留白问题\n\n< !--more-->\n    在h5的开发中总会有各种各样的问题，今天记录的主要是之前踩过的一个小坑。\n    在h5开发中,我们时常会用到表单去收集用户的填写的信息,正常来说,当input\n    框失去焦点的时候,软件盘自动收起。而在ios里软件盘收起后,页面内容会留白\n    不下滑.\n-   如下图:\n    ![](ios/input.jpeg?size=473x586)\n### 解决方案\n    \n    废话不多直接上代码：\n~~~bash\n    document.body.addEventListener('focusout', function () {\n        window.scrollTo(0,0);\n    });\n~~~\n- focusout：在元素失去焦点时触发。与 HTML 事件 blur 等价，冒泡\n  监听失去焦点时，让页面滚动到顶部来解决软件盘收起底部留白的问题。","tags":["前端"],"categories":["移动端开发常见问题"]},{"title":"vue封装自定义指令","url":"/2019/12/31/vue封装自定义指令/","content":"## VUE自定义指令\n\n    在 vue 中,有很多内置的指令.\n    如下:\n    v-for 用于遍历\n    v-if & v-show 用于隐藏和显示元素(区别在于后者是修改 display:block|none,前者是不创建把元素从dom中删除或者创建\n    v-bind: 属性绑定,把数据绑定在HTML元素的属性上.\n    v-html & v-text 把数据绑定在HTML元素的属性上,作用同 innerHTML & innerText\n    v-on: 绑定HTML元素事件\n    v-if & v-else-if & v-else 条件渲染\n    v-model 绑定表单元素,实现双向绑定.\n    我们知道，其实在实际项目开发里根据业务的需求我们会自定义一些指令来满足我们的需求，所以学会封装属于自己的自定义指令\n    对于项目的开发是很有必要的，我们知道自定义指令都是以v-开头，写在html属性的地方。\n< !--more-->\n## vue指令的生命周期？\n    自定义指令有五个生命周期（也叫钩子函数），分别是 bind,inserted,update,componentUpdated,unbind\n    1.bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。\n    2.inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。\n    3.update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板\n更新。\n    4.componentUpdated:被绑定元素所在模板完成一次更新周期时调用。\n    5.unbind:只调用一次，指令与元素解绑时调用。\n~~~bash\n    Vue.directive(\"mydirective\",{\n        bind:function (el, binding, vnode) { //1-被绑定\n            console.log(\"1-bind 被绑定\");\n            console.log(\"el:\",el);\n            console.log(\"binding:\",binding);\n            console.log(\"vnode:\",vnode);\n            el.style.color=binding.value;\n        },\n        inserted:function (el, binding, vnode) { //2-被插入\n            console.log(\"2-inserted 被插入\");\n        },\n        update:function (el, binding, vnode) { //3-更新\n            console.log(\"3-update 更新\");\n        },\n        componentUpdated:function (el, binding, vnode) { //4-更新完成\n            console.log(\"4-componentUpdated 更新完成\");\n        },\n        unbind:function (el, binding, vnode) { //5-解绑\n            console.log(\"5-unbind 解绑\");\n        }\n    });\n~~~\n## 让我们封装一个v-debounce的节流指令\n    节流函数自定义指令的封装，常用于实时搜索，用户验证\n    防止频繁触发性能消耗，在实际业务应用场景中比较常见，\n    让我看一下代码实现：\n~~~bash\n    debounce:{\n        inserted(el,binding){\n          let timer\n          el.addEventListener('keyup',()=>{\n            if(timer){\n              window.clearInterval(timer)\n            }\n            timer=setTimeout(()=>{\n               console.log(el.value,'输出')\n            },1000)\n          })\n        }\n      }\n~~~\n    这里要注意的是，clearInterval的前面要加上window,否则会报错timeout.close not a function.\n    使用的时候用v-debounce在html标签中，即可以实现一个简单的节流\n    函数指令\n## 总结\n    VUE这套框架,其实为开发者提供了很多内置的指令，但是有时候业务需求\n    是多变的,内置的指令很多时候不能满足我们的需求，所以VUE提供的自定\n    义指令在这个时候显得十分灵活，善于使用封装适合自己常用的指令，让\n    开发效率变得更高！\n## 参考资料","tags":["前端"],"categories":["vue"]}]